{"meta":{"title":"大胖笑","subtitle":"大胖笑","description":"","author":"Twyz.Liu","url":"https://blog.twyz.top","root":"/"},"pages":[{"title":"404","date":"2021-05-06T13:02:36.000Z","updated":"2021-05-06T13:08:10.681Z","comments":true,"path":"404/index.html","permalink":"https://blog.twyz.top/404/index.html","excerpt":"","text":""},{"title":"about","date":"2021-05-02T08:49:43.000Z","updated":"2021-05-06T13:01:35.036Z","comments":true,"path":"about/index.html","permalink":"https://blog.twyz.top/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-05-06T13:03:27.000Z","updated":"2021-05-06T13:04:08.051Z","comments":true,"path":"categories/index.html","permalink":"https://blog.twyz.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-05-06T13:02:12.000Z","updated":"2021-05-06T13:05:34.689Z","comments":true,"path":"tags/index.html","permalink":"https://blog.twyz.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"高效的代码管理Git","slug":"git","date":"2021-05-31T16:00:00.000Z","updated":"2021-06-01T15:45:05.435Z","comments":true,"path":"tools/git/","link":"","permalink":"https://blog.twyz.top/tools/git/","excerpt":"","text":"git介绍 历史和发展 Git诞生于一个充满争议和创举的时代。 1991-2002Linux内核开源项目有着众多的开发者，而大多数的内核维护工作在提交补丁、保存归档的事务上花费了太多时间。为什么呢？因为在2002年之前，世界各地的开发者把自己的改动通过diff生成补丁，再发给Linus(Linux之父)，Linux本人通过手动方式合并代码！ 2002-2005但是随着代码量的增加，开发者们认为这样的管理方式效率太低，Linus于是选择了(商业的)BitKeeper作为Linux的版本控制系统，BitKeeper的母公司出于人道主义，单独授权了Linux社区免费使用该版本控制系统。然而好景不长，在2005年，社区中有人试图破解BitKeeper协议的举动被该公司发现，随即收回了Linux社区的免费试用权，Linux社区再度陷入窘境….. 2005-NowLinus他和自己的团队花了两周的时间，用C写了一个分布式版本控制系统Git，一个月后，Git已经部署在了Linux社区中了。这一系列的操作不得不让人对Linus这个天才的感叹。直至今日，Git仍然是当今最好的代码版本控制系统。 git与svn 比较项 SVN Git 系统 集中式(便于文档管理)克隆1w commit的项目，需要1h 分布式(便于代码管理)克隆1w commit的项目，需要1min 灵活性 所有的操作都必须与中央服务器交互一旦出故障则无法工作 支持离线工作，即使服务器故障也没事可在本地进行各种操作，效率高 安全性 较差，需要定期备份 较高，人均一个库，充当备份作用 分支 切换一个分支=copy整个项目创建分支，会影响全组人员，大家都会有该分支 可以在任意节点创建分支，本地分支不会影响其他人，支持cherry-pick 版本控制 保存版本之间的差异，通过版本号进行控制每次操作都会产生(全局的)高版本号 只关心项目整体的数据变化通过hash值进行控制 权限 权限管理很严格，可按照组、目录进行权限控制每个目录下都有一个.svn文件 没有严格的权限控制，只有角色划分在主目录下有.git目录 git操作 流程概览 git的基本流程有4个：stage，commit，push，pull。 初始化这里的Workding Directory就是我们当前的工作目录，当我们克隆一个项目/初始化一个仓库后，我们的状态为最新。 git clone https://github.com/Lucky-Jenny/Code_Study.git git status 改动在上述状态下，我们做的所有改动都将会被监视，分为untracked和unstaged两个状态。 untracked: 不属于本仓库内的文件(新添加的)； unstaged: 修改了属于本仓库内的文件； 暂存 暂存区的作用：区分当前仓库中哪些文件/目录需要提交。 当我们的改动需要暂时保存起来，可以用add/rm进行暂存。不暂存的哪些文件则不会被提交(状态保持)。 此时，切换到其他分支，我们查看状态，可以发现所有的分支都能显示了改动。 暂存区的改动对所有分支都是有效的。 提交 本地仓库的作用：本地项目的正式改动保存，待确认无误推送到远程仓库。 我们把暂存区的改动进行提交 git commit -m \"Add Atoi.c xxx\" git status 提交之后，本地仓库比远程仓库多了一次改动。这时我们切换到别的目录，却没有该提交。 本地仓库的提交只对当前提交的分支有效，对其他分支无效。 其实这一点是可以推理的，试想：若每次提交都每个分支上，那么每个分支的所有改动都是一样的，那分支的意义在哪里呢？ 分支分支(branch)是版本管理中非常有效的机制，例如一个项目中，我负责模块A，他负责模块B，我们可以在各自的分支中编辑代码，这样不同模块的代码在分支合并时就不会发生冲突。 git branch -a # 查看本地 &amp; 远程的所有分支 git checkout master # 切换到分支&lt;master&gt; git merge script # 在&lt;master&gt;中把&lt;script&gt;合并进来 我们通过tig(git的可视化工具)查看merge之后的master仓库： 标签标签(tag)是对项目某个阶段进度的一种标记方式，我们可以通过标签去找到当时的项目仓库改动。 git tag study-v1.1 # 添加标签 git tag -l # 查看所有的标签 注意：标签不会随着git push添加到远程仓库中。如果我们想把标签推送至服务器，记住如下指令： git push origin --tags # 仅推送标签，不推送其他任何改动 远程仓库和本地仓库 远程仓库其实就是远程架设了一个服务器，供开发成员进行推送和拉取操作。 推送推送：git push。形象地理解为把所提交的改动发送到远程的服务器上，只有推送到远程仓库之后，其他的组员方可从该仓库获取改动。注意：我们既可以推送新的改动，又可以推送过去重新编辑的改动，但是极其不建议后者的操作。为什么呢？我们来看下面这个例子： ABC三位开发人员共同在package/wifi/目录下进行为期一周的开发任务。在第6天的时候，A发现B在第1天的提交X有问题，于是他修改了X： git rebase -i &lt;Commit-X&gt; # 将要修改的提交ID，前面的`pick`改成`edit`，保存退出。 # 自动弹出该提交的信息，修改完保存退出。 # 此时HEAD应该回到原来的位置，若没有的话则执行以下操作： git rebase --continue 注：该方法会更改从X到HEAD的所有commit的hash值。 与此同时B和C基于第5天的仓库进行本地的修改。A向远程仓库推送X的改动之后，B和C从远程仓库获取X的改动，此时会发生冲突(本地仓库最新是第6天的改动，而远程仓库是第5天的改动)，导致B和C本地的改动直接作废。这是因为从第一天到第5天已经提交了许多改动，即使B和C本地reset到第一天的代码，仍然无法兼容第6天的改动。 因此，修改过去的提交，我们建议采用以下两种方式： # 方法一：revert git revert &lt;Commit-ID&gt; # 原来的改动和这次的撤销都保存在历史中 # 方法二：reset git reset HEAD~2 # 向后回滚两次改动，保留当前的改动 git reset &lt;Commit-ID&gt; # 回滚到过去某一次的改动 git reset --hard HEAD~4 # --hard 强制回滚，所有之前的改动全部删除 拉取拉取：git pull。在流程图中，我们会发现拉取的方向和另外两个动作是一致的，即fetch和checkout。这里就要好好叙述他们的区别： git pull # 从远程仓库获取全部分支的最新改动，到工作区。 git fetch # 从远程仓库获取全部分支的最新改动，到暂存区。 git fetch origin master # 从远程仓库获取&lt;master&gt;分支的最新改动。 git checkout leetcode # 切换到&lt;leetcode&gt;分支获取最新改动，到工作区。 综上，我们可以总结： 当获取当前分支的改动时，git pull = git fetch + git checkout &lt;branch&gt; 实际应用 在实际的工作环境中，也会遇到许多问题，针对这些问题可以有许多的解决办法，我们希望采用最佳的方法去解决。 遇到的问题 工作区的暂时备份 A正在修改代码尚未完成，此时有紧急的问题需要优先处理，应该如何快速保存当前的任务状态？ 最简单的方法当然是：COPY。但反复的复制粘贴，其实效率并不高，我们期望有一个指令能够迅速备份，迅速还原：stash。 git stash # 将当前工作区中的改动保存起来，还原现场。 git stash pop # 把先前保存的工作区修改，恢复出来。 git stash clear # 丢弃之前保存的工作区的修改。 注：stash不保存untracked文件，只保存unstaged文件。 查看具体的提交信息 A想知道在data_select.c中的134行代码是谁在何时修改的。 # 方法一：tig tig -&gt; g(grep):firmware # 根据关键词，在tig中查找 # 方法二：blame git blame -L 133,135 data_select.c 二分法溯源 现有一个bug无法定位其根源，已知该bug是发生在tag &lt;V1.2&gt;和tag &lt;V1.6&gt;之间，而这两个标签之间有100+个提交，线性排查一定是最低效的，有没有高效率的方法？ git中有一个非常实用的检索工具：git-bisect，它采用的方式为二分法。 # 将HEAD移至&lt;V1.2&gt;和&lt;V1.4&gt;中间的提交 git-bisect start &lt;V1.4&gt; &lt;V1.2&gt; # 注意顺序不要反 # 将HEAD回到原先(最新)的位置 git-bisect reset 当遇到分支时，比如有4个分支，则定位每个分支中的最新节点，分别测试： 若都存在该问题，则说明与这些分支无关，回到主分支中； 若1个分支存在，则追溯该分支；若2个分支存在，则追溯他俩上次分叉的位置； tig tig作为git的可视化工具，对于开发人员来说是非常有用的工具。这里着重介绍一下tig相关的命令和快捷键： 命令tig # 查看当前项目的改动历史 tig . # 查看当前目录的改动历史 注意：只有当前目录为git仓库，tig才会有效。 快捷键进入到tig后，我们可以通过下面的快捷键来进行操作： 键 等价于 含义 l git log 详细的改动历史 r git branch 所有的分支 s git status 当前暂存和临时的修改 c git stash pop 查看临时保存的内容 t tree 以树形结构查看仓库，&lt;Enter&gt;进入 &lt;,&gt;退出 / git branch 当前提交中搜索关键词 g grep 所有提交中搜索关键词","categories":[{"name":"tools","slug":"tools","permalink":"https://blog.twyz.top/categories/tools/"}],"tags":[{"name":"git","slug":"git","permalink":"https://blog.twyz.top/tags/git/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-05-15T16:54:09.010Z","updated":"2021-05-15T16:54:09.011Z","comments":true,"path":"uncategorized/hello-world/","link":"","permalink":"https://blog.twyz.top/uncategorized/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"不安分的指针","slug":"pointer","date":"2021-05-14T16:00:00.000Z","updated":"2021-05-15T16:35:29.805Z","comments":true,"path":"language/pointer/","link":"","permalink":"https://blog.twyz.top/language/pointer/","excerpt":"","text":"基本篇 什么是指针？ 当提到指针，学过编程的我们第一反应：就是它让我从C入门到放弃…..说句实话，笔者在接触Linux之前，对它的态度亦是敬而远之，诸如”Segmentation fault”，”memory leak”这些令人抓狂的log是一切痛苦的根源，一个问题就能让初学C的我尝试解决大半天。但了解嵌入式相关的底层架构之后，笔者还是不由感叹，指针对于C来说，对于内存的访问确实高效！ 在Google的搜索列表中，关于”C”, “指针”的结果总是与原理相关，偶然发现一个有趣的问题：指针为什么是C语言的精髓？ 笔者借鉴以前在知乎上看到的一句话，非常值得思考：指针不是什么精髓，它只是一扇门，推开它后，就是一个世界。 指针的概念 指针是C/C++中用来指向内存地址的类型。 注意：这句话的两个关键词：指向、类型。 Q1: 为什么不说指针就是内存地址，而要多一个指向？笔者认为“指针就是内存地址”的观点并不严谨，不然为何不称之为地址？这里，指向表明它是一个过程，包含两个动作： 根据地址索引找到内存块中的栈/堆区； 访问该栈/堆区，进行数据的读/写； Q2: 它属于基本数据类型吗？指针不属于基本数据类型，C11将它专门划分为：**指针类型**。 指针的定义 指针*p：表示内存地址中的的数据； 指针变量p：表示内存地址； 我们可以从下图形象地理解指针： 图中紫色地址保存的是指针p，红色地址保存的是变量var。而指针p本身的值就是var的地址，故表示：指针p指向变量var。 指针的赋值方式有两种操作(本质相同)： int *p = a; // `指针p`指向`变量a` (实质指向地址) int p = &amp;a; // 把`变量a`的地址给`指针变量p` 注意：这里int是指针的基类型。 Q3：基类型是干什么的？基类型包含基本数据类型、结构体等，它的作用是声明该指针在读写数据时的地址区域。我们知道，程序通过指针的地址从内存中读取数据，但是读多少呢？这就需要对指针指定一个基类型，用来告诉程序”读取多少数据“。下面举例指针在字符串中的应用，这里我把基类型称之为步长。 char s[] = \"Jenny is walking her dog.\"; char *p = s; printf(\"s: %s\\n\", p); // %s从字符串的起始地址开始读，直到遇到'\\0' for(int i = 0; i &lt; strlen(s); i++){ printf(\"%c\", *p); // *p从内存中获取字符，%c直接读*p p++; // p每次走的步长即为基类型(char)的内存大小 } 通过上面的例子，相信读者对基类型能有基本的理解。 阐明了指针如何读/写其他数据的方式，那指针本身又是如何存储的呢？ Q4：指针本身分配内存吗？大小是多少？值得一提的是，指针本身的数据类型为unsigned int，通过格式化中的转义字符可以验证。 char *p = str; printf(\"%d\", p); // 十进制—&gt; 1651581740 printf(\"%p\", p); // 16进制—&gt; 0x7ffd6271232c 指针在程序段中表示内存地址，无论我们定义的基类型是char还是struct，指针本身所占的内存空间(具体大小参考下表)都是不变的，但这不代表它是基本数据类型。 指针所占内存空间取决于CPU的寻址位数。 CPU寻址位数 指针占内存空间 16 2 bytes 32 4 bytes 64 8 bytes 为什么需要指针？ 学习了指针的基本概念，或许有朋友会疑惑：指针并不友好，我们为什么需要它呢？你看Python、Java这些高级语言都没有指针，对于内存管理机制不是也很好吗？ 对比高级语言其实Java、Python(包括C++)中也有类似指针一样访问内存的机制——引用。有引用就一定有对象，对象可以是任何实体类型(类、数组、函数等)，其本质上也是指向内存地址，但请注意：引用只是一个傀儡，它不能被改变，只能被调用。具体可以从指针与引用的区别中体会： 引用必须有初始化，不分配内存空间，指针未必有初始化，但分配内存空间； 引用的对象不能为空，指针可以为空； 引用的对象不能改变，指针初始化后还能改变； “sizeof(引用)”=对象的大小，”sizeof(指针)”=指针本身大小； 引用保证了程序的类型(内存)安全； 这里额外提一下最后一点：引用在初始化时多了类型检查以保证内存安全，因此引用对象在调用时很少会出现”内存泄漏”等错误。 上面这些都是引用和指针的基本区别，其实第一点”不分配内存空间”就能推理出下面3点。从这些区别可以直观地感受到引用的局限性，相比之下，指针灵活很多，用户可以直接进行内存的管理分配，这就是为什么我们在嵌入式编程中(C)中需要指针。 指针的作用笔者认为指针是非常重要的，单凭一句话不足以说服大家。所以，我们来探讨一下指针的作用： 1. 高效地共享内存数据在小规模的程序中，数据的共享可以通过赋值(复制)来实现。但是当代码量达到一定的规模时，这样的方式会占用大量的内存，比如我们传递结构体、链表、三维数组等。有了指针，我们可以直接把内存地址告诉程序段，实现数据的共享，既节省了内存的消耗，又提高了运行效率。 2. 动态地分配内存普遍情况下，程序在声明变量时都是显式地分配内存(静态内存分配)。而当程序无法判断所声明对象需要多少内存时，就需要用到指针，实现在运行时分配内存(动态内存分配)。注意： 静态内存分配：编译时分配，存放于**栈区**。对象—&gt; 全局(静态)变量、局部静态变量； 动态内存分配：运行时分配，存放于**堆区**。对象—&gt; 局部变量、动态内存分配(malloc)变量； 3. 字符串处理在Java中，几乎所有的字符串的处理都可调用其库中的工具类，而在C/C++中，常见的字符串处理函数常并不多，如： strlen(s); // 注意s为指针的话，此函数无效 strncpy(target, src, sizeof(src)); // 字符串的赋值 strncmp(str1, str2, len); // 字符串的比较 snprintf(s, sizeof(s), format ... ); // 字符串的格式化赋值 当我们需要对字符串作其他处理，就必须用到指针。通过指针访问内存区，我们可以直接在每个步长中处理单个字符(char)，也可以进行遍历。例如，我们常用的链表结构，也是依赖于指针的帮助，无非是处理的步长从单个字符到单个链(结构体)： p++; // 字符串中的遍历方式 LNode_x = LNode_x-&gt;next; // 单链表中的遍历方式 4. 函数返回多个值C语言规定：一个函数只能有一个返回值，我们只能通过return返回一个变量。但是我们可以通过指针+结构体返回多个变量： typedef struct Person{ int age; char *name; int gender; }*Prs; Prs *create_Per() { Prs *p = NULL; p-&gt;name = (char*)malloc(sizeof(char) * 8); ... // 赋值 return p; } 其实这里的多个变量，也可以理解为一个变量，只是我们定义了一个对象把多个变量封装起来。 在基本篇中，我们着重讲述了指针的几个基本问题：what, how, why。而作为C语言的开发人员，仅仅知晓这些肯定是完全不够的，更多的细节问题还需要读者们在平时写代码中自行总结和发现。记住：编程的学习一定是在发现问题中得到成长。 进阶篇 在接下来的进阶篇中，笔者将根据过往的经验总结一些指针在实际应用中的问题。 指针的操作 关于指针的操作，除了最基本的赋值与调用，在实际情况中还有许多相关的操作。例如，在函数传参中的调用、指针与指针变量的自增运算等。在阅读之前，笔者再次强调，指针是内存的访问，我们脑中必须要有内存单元的概念。 函数传参中的指针引用首先，我们要清楚C语言关于的函数参数的一些概念： 形参(形式参数)：函数定义中，它所声明的参数变量(没有实际数据)； void TakeParm(char *source, int num, char target); 实参(实际参数)：函数被调用时，它在当前程序段中调用的其他实体变量； TakeParm(str, 3, chr); 当函数被调用时，程序会给形参分配相应类型大小的内存，实参的值传递给形参。注意传参是赋值、单向的，因此形参的值不会影响实参的值。但请特别注意：当函数调用结束时，会立即释放形参的所分配的内存单元。 C语言的函数传参有两种方式：值传递、地址传递。 C++的函数传参有3种方式：值传递、地址传递、引用传递。 值传递该传参方式是把变量、常量、数组作为函数参数，本质上是把实参的值复制到形参的存储单元。这意味着形参和实参在不同内存单元中存储相同的值，故称之为”值传递”。 void Sub(int a, int b) { int c = a; a = b; b = c; printf(\"a=%d b=%d\\n\", a, b); // a=4 b=9 } int main() { int m = 9, n = 4; Sub(m, n); printf(\"m=%d n=%d\\n\", m, n); // a=9 b=4 } 上面的例子中，我们验证了值传递的本质：值的复制。不过，我们也发现了形参在函数中能够改变值，但在函数调用完后，两个值又“恢复原样”了。前面说过，由于传参的单向性，形参是不会影响到实参的值，因此m, n两个值压根就没有变动。那么如何让形参在函数调用时影响到实参？ 地址传递顾名思义，地址传递的意思是把地址作为传参，这就需要用到指针。严格来说，地址传递的对象是数组/指针，参数是数组的首地址/指针的值。因此，实参到形参传递的是地址，他们访问的便是相同的内存空间。 void Sub(int *a, int *b) { int c = *a; *a = *b; *b = c; printf(\"a=%d b=%d\\n\", *a, *b); // a=4 b=9 } int main() { int m = 9, n = 4; Sub(&amp;m, &amp;n); printf(\"m=%d n=%d\\n\", m, n); // a=4 b=9 } 与值传递对比，实参和形参都有不同。实参中，&amp;代表取地址符，即把m和n的地址作为参数传给形参，注意：形参本身获取的是地址，等同于： a = &amp;m; b = &amp;n; 这样，指针变量a, b是m, n的地址，则对指针*a, *b的操作也就是对m, n变量的操作。所以，在函数调用结束后，实参得到了改变。 引用传递再次强调，C语言没有引用类型。关于引用，我们在对比高级语言中介绍了它的特点(不多赘述)，它的取地址符&amp;。引用传递的本质其实也是通过指针来实现的，以指针的方式实现值传递。 void Sub(int &amp;a, int &amp;b) // 形参的格式与值传递不同 { int c = a; a = b; b = c; printf(\"a=%d b=%d\\n\", a, b); // a=4 b=9 } int main() { int m = 9, n = 4; Sub(m, n); printf(\"m=%d n=%d\\n\", m, n); // a=9 b=4 } 上面的例子，如果使用gcc编译一定会报错，而使用g++会执行通过。 了解原理之后，我们做一个总结： 如果形参和实参都是基本数据类型，就是值传递； 如果实参是形参的指针，就是地址传递； 如果形参为引用类型&amp;x，就是引用类型； *(p++) or (*p++) ?关于指针的操作，前面提到过还有自增/减的操作。在基本变量中，a++等于a=a+1，那么，在指针里，*p++等于*p=*p+1吗？ 正常情况下，++优先级高于*。 指针自增操作： 表达式 含义 *p++ / *(p++) ++在后，故先取值*p，再把指针变量p++(地址增加) (*p)++ *p为整体，故先取值*p，再使*p的值++ *++p / *(++p) ++在前，故先把指针变量p++，再取值*p ++*p *p为整体，故先使*p的值++，再取*p的值 注意：第一行中的*p++，*与p是分离的。 可能有朋友看到这么绕的表达式，觉得脑子都要搞糊涂了….其实我们通过理解，根本不需要去记这些表达式的含义： 当指针被括号括起来时，我们认为(*p)就是一个变量，把它当做a++处理就完事了； 当指针没有被括起来(*与p分离)时，我们认为p++就是地址的自增操作，然后再通过*取值； 带着这样的思路，我们再回过头看这张表，是不是瞬间觉得简单易懂？ 指针的状态 有朋友要问了，指针的状态不就是：NULL、存在地址和释放吗？这没啥好讨论的吧。如果是简单的使用，就记住这3个状态是没问题的，但既然是讲指针，笔者还是希望把深层的原理阐明清楚。 NULL和空指针Q5：你能区分NULL指针、空指针、零指针吗？先把一些相关的概念问题罗列一下： void*类型指针：通用变体型指针，可以不加转换直接赋值给其他指针； 空指针常量：C标准中，值为0的整型常量/强制转为void类型的表达式； 空指针：p=0，不指向任何实际对象/函数的指针； NULL指针：标准的宏定义，用来表示空指针常量； #define NULL ((void*) 0) 零指针：*p=0，值为0的指针，没有存储任何地址的指针，类型可以是*void, *int, *char等； 综上，我们总结了一些平时几乎没有见到的各种指针状态，从应用角度来说，这些思维的区别几乎可以省略，因为它们都有一个特征：都可以转化为*void类型，说明了它们本身的存在是不依赖于实际对象。强调一下，空指针包括NULL指针和零指针。 野指针 野指针：未初始化的指针； 悬垂指针：从栈释放/删除一个对象后，指针仍然会指向该地址； 在C语言中，指针是允许不被初始化，但是往往这样开放的规则会带来极大的危害。所有未初始化的指针都可以被称为野指针，直到该指针被赋予一个实际对象的内存地址。而在指针的释放机制中，free(p)释放的是指针指向的那一段内存空间，并非指针本身，如果悬垂指针在后续继续被调用，那它就是一个指向垃圾内存的指针，这样的指针是很容易使程序运行致崩溃。 对于上述这些情况，我们能够最恰当的解决方式是全部赋予空指针常量： char *p = NULL; ... free(p); p = NULL;","categories":[{"name":"language","slug":"language","permalink":"https://blog.twyz.top/categories/language/"}],"tags":[{"name":"C","slug":"C","permalink":"https://blog.twyz.top/tags/C/"}]},{"title":"Markdown语法介绍","slug":"Markdown","date":"2021-05-01T16:00:00.000Z","updated":"2021-05-15T15:30:20.569Z","comments":true,"path":"grammar/Markdown/","link":"","permalink":"https://blog.twyz.top/grammar/Markdown/","excerpt":"","text":"基本语法强调1.粗体/斜体使用语法： **粗体** *斜体* ***粗体+斜体*** 粗体 斜体 粗体+斜体 2.删除线使用语法： ~~这句话不要了~~ 这句话不要了 3.高亮当我们需要在一段话中高亮某些关键词，可以用&lt;html&gt;中的&lt;span&gt;标签来强调。 VPN对数据包的处理是 &lt;span style=”background-color:#ffd351”&gt;通过封装包头(header)&lt;/span&gt;，继而在GFW外的主机上进行剥离，反之亦然。 VPN对数据包的处理是 通过封装包头(header) ，继而在GFW外的主机上进行剥离，反之亦然。 引用内容 当我们需要引用内容时，可以再前面加 ‘&gt;’如果需要换行，可以在末尾+两个空格/‘&lt;br&gt;‘ 这是嵌套引用 如果吃饱了没事干，可以一直套娃 尽量不要嵌套引用，不美观。 列表 可以用 ‘*’ ‘+’ ‘-‘ 作为标记 我还是习惯用’-‘吧，’*‘ 容易与粗体搞混 1.有序列表 开头必须是数字，后面必须跟’.’ 注意：’.’后面一定要有空格 如果下面也有序号列表，当中要空一行，否则序号承接 2.嵌套列表 first floor second floor 2-1 2-2 third floor 有序无序可随意嵌套； 标记后面一定要有空格； 当然，利用转义字符’.‘，它就不再是个列表了； fourth floor….. 分割线分割线必须是3个以上的字符 *, -, _表示, 字符间可以有空格，但不能有其他字符 *** - - - _ __ 显示：(分割线) 表格使用语法：“|” 分隔单元格，”-“ 分隔表头和行 | name | age || :—-: | :— || Twyz | 24 || Jenny | 25 | name age Twyz 24 Jenny 25 表头下方的分割线标记，代表了对齐方式： :— 左对齐 :—: 居中对齐 —: 右对齐 | left | center | right ||:—- | :—-: | —-: || aaaa | bbbbbb | ccccc || a | b | c | left center right aaaa bbbbbb ccccc a b c 超链接使用语法： [markdown基本语法](https://xianbai.me/learn-md/index.html)\\ markdown基本语法或者直接用原地址：http://www.baidu.com/这适合较短的网址 图片使用语法： ![panda](https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100 “GitHub,Social Coding”) 也可设置图片大小 &lt;img src=\"https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100\" alt=\"GitHub\" title=\"GitHub,Social Coding\" width=\"50\" height=\"50\" /&gt; 代码块使用语法： int main() { int x = 0; } 表情符号使用语法： :&lt;表情代码&gt;: 举例： 😄 smile😆 laughing:+1: +1👏 clap 更多的表情，请参考：webpage-tool","categories":[{"name":"grammar","slug":"grammar","permalink":"https://blog.twyz.top/categories/grammar/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://blog.twyz.top/tags/Markdown/"}]}],"categories":[{"name":"tools","slug":"tools","permalink":"https://blog.twyz.top/categories/tools/"},{"name":"language","slug":"language","permalink":"https://blog.twyz.top/categories/language/"},{"name":"grammar","slug":"grammar","permalink":"https://blog.twyz.top/categories/grammar/"}],"tags":[{"name":"git","slug":"git","permalink":"https://blog.twyz.top/tags/git/"},{"name":"C","slug":"C","permalink":"https://blog.twyz.top/tags/C/"},{"name":"Markdown","slug":"Markdown","permalink":"https://blog.twyz.top/tags/Markdown/"}]}