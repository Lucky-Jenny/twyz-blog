<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高效的代码管理Git</title>
      <link href="tools/git/"/>
      <url>tools/git/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="git介绍"><a href="#git介绍" class="headerlink" title="git介绍"></a>git介绍</h2><hr><h3 id="历史和发展"><a href="#历史和发展" class="headerlink" title="历史和发展"></a>历史和发展</h3><hr><p>Git诞生于一个充满争议和创举的时代。</p><h4 id="1991-2002"><a href="#1991-2002" class="headerlink" title="1991-2002"></a>1991-2002</h4><p>Linux内核开源项目有着众多的开发者，而大多数的内核维护工作在提交补丁、保存归档的事务上花费了太多时间。为什么呢？因为在2002年之前，世界各地的开发者把自己的改动通过diff生成补丁，再发给Linus(Linux之父)，Linux本人通过<strong>手动</strong>方式合并代码！</p><h4 id="2002-2005"><a href="#2002-2005" class="headerlink" title="2002-2005"></a>2002-2005</h4><p>但是随着代码量的增加，开发者们认为这样的管理方式效率太低，Linus于是选择了(商业的)BitKeeper作为Linux的版本控制系统，BitKeeper的母公司出于人道主义，单独授权了Linux社区免费使用该版本控制系统。然而好景不长，在2005年，社区中有人试图破解BitKeeper协议的举动被该公司发现，随即收回了Linux社区的免费试用权，Linux社区再度陷入窘境…..</p><h4 id="2005-Now"><a href="#2005-Now" class="headerlink" title="2005-Now"></a>2005-Now</h4><p>Linus他和自己的团队花了<span style="background-color:#F9FC17">两周</span>的时间，用C写了一个<strong>分布式</strong>版本控制系统Git，一个月后，Git已经部署在了Linux社区中了。这一系列的操作不得不让人对Linus这个天才的感叹。直至今日，Git仍然是当今最好的代码版本控制系统。</p><h3 id="git与svn"><a href="#git与svn" class="headerlink" title="git与svn"></a>git与svn</h3><hr><table><thead><tr><th align="left">比较项</th><th align="left">SVN</th><th align="left">Git</th></tr></thead><tbody><tr><td align="left">系统</td><td align="left">集中式(便于文档管理)<br>克隆1w commit的项目，需要1h</td><td align="left">分布式(便于代码管理)<br>克隆1w commit的项目，需要1min</td></tr><tr><td align="left">灵活性</td><td align="left">所有的操作都必须与中央服务器交互<br>一旦出故障则无法工作</td><td align="left">支持离线工作，即使服务器故障也没事<br>可在本地进行各种操作，效率高</td></tr><tr><td align="left">安全性</td><td align="left">较差，需要定期备份</td><td align="left">较高，人均一个库，充当备份作用</td></tr><tr><td align="left">分支</td><td align="left">切换一个分支=copy整个项目<br>创建分支，会影响全组人员，大家都会有该分支</td><td align="left">可以在任意节点创建分支，本地分支不会影响其他人，支持<strong>cherry-pick</strong></td></tr><tr><td align="left">版本控制</td><td align="left">保存版本之间的差异，通过<strong>版本号</strong>进行控制<br>每次操作都会产生(全局的)高版本号</td><td align="left">只关心项目整体的数据变化<br>通过<strong>hash值</strong>进行控制</td></tr><tr><td align="left">权限</td><td align="left">权限管理很严格，可按照组、目录进行权限控制<br>每个目录下都有一个.svn文件</td><td align="left">没有严格的权限控制，只有角色划分<br>在主目录下有.git目录</td></tr></tbody></table><p><img src="/pics/git/git_vs_svn.png" alt="svn-git"></p><hr><h2 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h2><hr><h3 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h3><hr><p>git的基本流程有4个：stage，commit，push，pull。</p><p><img src="/pics/git/git-flow.png" alt="git-flow"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>这里的Workding Directory就是我们当前的工作目录，当我们克隆一个项目/初始化一个仓库后，我们的状态为<strong>最新</strong>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/Lucky-Jenny/Code_Study.git<span class="token function">git</span> status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/pics/git/status-uptodate.png" alt="init-status"></p><h4 id="改动"><a href="#改动" class="headerlink" title="改动"></a>改动</h4><p>在上述状态下，我们做的所有改动都将会被监视，分为<code>untracked</code>和<code>unstaged</code>两个状态。</p><p><img src="/pics/git/status-unstaged.png" alt="unstaged-status"></p><ul><li>untracked: 不属于本仓库内的文件(新添加的)；</li><li>unstaged: 修改了属于本仓库内的文件；</li></ul><h4 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h4><blockquote><p>暂存区的作用：区分当前仓库中哪些文件/目录需要提交。</p></blockquote><p>当我们的改动需要<strong>暂时</strong>保存起来，可以用add/rm进行暂存。不暂存的哪些文件则不会被提交(状态保持)。</p><p><img src="/pics/git/staged-master.png" alt="staged-in-master"></p><p>此时，切换到其他分支，我们查看状态，可以发现所有的分支都能显示了改动。</p><p><img src="/pics/git/staged-leetcode.png" alt="staged-in-leetcode"></p><blockquote><p>暂存区的改动对<strong>所有分支</strong>都是有效的。</p></blockquote><h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><blockquote><p>本地仓库的作用：本地项目的正式改动保存，待确认无误推送到远程仓库。</p></blockquote><p>我们把暂存区的改动进行提交</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> commit -m <span class="token string">"Add Atoi.c xxx"</span><span class="token function">git</span> status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/pics/git/commit-1.png" alt="commit-status"></p><p>提交之后，本地仓库比远程仓库多了一次改动。这时我们切换到别的目录，却<strong>没有该提交</strong>。</p><blockquote><p>本地仓库的提交<strong>只对当前提交的分支有效</strong>，对其他分支无效。</p></blockquote><p>其实这一点是可以推理的，试想：若每次提交都每个分支上，那么每个分支的所有改动都是一样的，那分支的意义在哪里呢？</p><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>分支(branch)是版本管理中非常有效的机制，例如一个项目中，我负责模块A，他负责模块B，我们可以在各自的分支中编辑代码，这样不同模块的代码在分支合并时就不会发生冲突。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> branch -a          <span class="token comment"># 查看本地 &amp; 远程的所有分支</span><span class="token function">git</span> checkout master    <span class="token comment"># 切换到分支&lt;master&gt;</span><span class="token function">git</span> merge script       <span class="token comment"># 在&lt;master&gt;中把&lt;script&gt;合并进来</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们通过<code>tig</code>(git的可视化工具)查看merge之后的master仓库：</p><p><img src="/pics/git/merge.png" alt="tig-merge"></p><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>标签(tag)是对项目某个阶段进度的一种标记方式，我们可以通过标签去找到当时的项目仓库改动。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> tag study-v1.1      <span class="token comment"># 添加标签</span><span class="token function">git</span> tag -l              <span class="token comment"># 查看所有的标签 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/pics/git/tig-tag.png" alt="tig-tag"></p><p>注意：<span style="background-color:#F9FC17">标签不会随着git push添加到远程仓库中</span>。如果我们想把标签推送至服务器，记住如下指令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push origin --tags      <span class="token comment"># 仅推送标签，不推送其他任何改动</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="远程仓库和本地仓库"><a href="#远程仓库和本地仓库" class="headerlink" title="远程仓库和本地仓库"></a>远程仓库和本地仓库</h3><hr><p>远程仓库其实就是远程架设了一个服务器，供开发成员进行推送和拉取操作。</p><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>推送：<code>git push</code>。形象地理解为把所提交的改动发送到远程的服务器上，只有推送到远程仓库之后，其他的组员方可从该仓库获取改动。注意：我们既可以推送新的改动，又可以推送过去<strong>重新编辑</strong>的改动，但是极其不建议后者的操作。为什么呢？我们来看下面这个例子：</p><p>ABC三位开发人员共同在package/wifi/目录下进行为期一周的开发任务。在第6天的时候，A发现B在第1天的提交X有问题，于是他修改了X：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> rebase -i <span class="token operator">&lt;</span>Commit-X<span class="token operator">&gt;</span><span class="token comment"># 将要修改的提交ID，前面的`pick`改成`edit`，保存退出。</span><span class="token comment"># 自动弹出该提交的信息，修改完保存退出。</span><span class="token comment"># 此时HEAD应该回到原来的位置，若没有的话则执行以下操作：</span><span class="token function">git</span> rebase --continue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：该方法会<span style="background-color:#F9FC17">更改从X到HEAD的所有commit的hash值</span>。</p><p>与此同时B和C基于第5天的仓库进行<strong>本地</strong>的修改。A向远程仓库推送X的改动之后，B和C从远程仓库获取X的改动，此时会发生冲突(<em>本地仓库最新是第6天的改动，而远程仓库是第5天的改动</em>)，导致B和C<strong>本地的改动直接作废</strong>。这是因为从第一天到第5天已经提交了许多改动，即使B和C本地<code>reset</code>到第一天的代码，仍然无法兼容第6天的改动。</p><p>因此，修改过去的提交，我们建议采用以下两种方式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 方法一：revert</span><span class="token function">git</span> revert <span class="token operator">&lt;</span>Commit-ID<span class="token operator">&gt;</span>       <span class="token comment"># 原来的改动和这次的撤销都保存在历史中</span><span class="token comment"># 方法二：reset</span><span class="token function">git</span> reset HEAD~2          <span class="token comment"># 向后回滚两次改动，保留当前的改动</span><span class="token function">git</span> reset <span class="token operator">&lt;</span>Commit-ID<span class="token operator">&gt;</span>     <span class="token comment"># 回滚到过去某一次的改动</span><span class="token function">git</span> reset --hard HEAD~4   <span class="token comment"># --hard 强制回滚，所有之前的改动全部删除</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p>拉取：<code>git pull</code>。在流程图中，我们会发现拉取的方向和另外两个动作是一致的，即<code>fetch</code>和<code>checkout</code>。这里就要好好叙述他们的区别：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> pull                 <span class="token comment"># 从远程仓库获取全部分支的最新改动，到工作区。</span><span class="token function">git</span> fetch                <span class="token comment"># 从远程仓库获取全部分支的最新改动，到暂存区。</span><span class="token function">git</span> fetch origin master  <span class="token comment"># 从远程仓库获取&lt;master&gt;分支的最新改动。</span><span class="token function">git</span> checkout leetcode    <span class="token comment"># 切换到&lt;leetcode&gt;分支获取最新改动，到工作区。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>综上，我们可以总结：</p><blockquote><p>当获取当前分支的改动时，git pull = git fetch + git checkout &lt;branch&gt;</p></blockquote><hr><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><hr><p>在实际的工作环境中，也会遇到许多问题，针对这些问题可以有许多的解决办法，我们希望采用最佳的方法去解决。</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><hr><h4 id="工作区的暂时备份"><a href="#工作区的暂时备份" class="headerlink" title="工作区的暂时备份"></a>工作区的暂时备份</h4><blockquote><p>A正在修改代码尚未完成，此时有紧急的问题需要优先处理，应该如何快速保存当前的任务状态？</p></blockquote><p>最简单的方法当然是：COPY。但反复的复制粘贴，其实效率并不高，我们期望有一个指令能够迅速备份，迅速还原：stash。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> stash           <span class="token comment"># 将当前工作区中的改动保存起来，还原现场。</span><span class="token function">git</span> stash pop       <span class="token comment"># 把先前保存的工作区修改，恢复出来。</span><span class="token function">git</span> stash <span class="token function">clear</span>     <span class="token comment"># 丢弃之前保存的工作区的修改。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注：<span style="background-color:#F9FC17">stash不保存untracked文件</span>，只保存unstaged文件。</p><h4 id="查看具体的提交信息"><a href="#查看具体的提交信息" class="headerlink" title="查看具体的提交信息"></a>查看具体的提交信息</h4><blockquote><p>A想知道在data_select.c中的134行代码是<strong>谁在何时</strong>修改的。</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 方法一：tig</span>tig -<span class="token operator">&gt;</span> g<span class="token punctuation">(</span>grep<span class="token punctuation">)</span>:firmware       <span class="token comment"># 根据关键词，在tig中查找</span><span class="token comment"># 方法二：blame</span><span class="token function">git</span> blame -L <span class="token number">133,135</span> data_select.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二分法溯源"><a href="#二分法溯源" class="headerlink" title="二分法溯源"></a>二分法溯源</h4><blockquote><p>现有一个bug无法定位其根源，已知该bug是发生在tag &lt;V1.2&gt;和tag &lt;V1.6&gt;之间，而这两个标签之间有100+个提交，线性排查一定是最低效的，有没有高效率的方法？</p></blockquote><p>git中有一个非常实用的检索工具：<span style="background-color:#00FA9A">git-bisect</span>，它采用的方式为<strong>二分法</strong>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将HEAD移至&lt;V1.2&gt;和&lt;V1.4&gt;中间的提交</span>git-bisect start <span class="token operator">&lt;</span>V1.<span class="token operator"><span class="token file-descriptor important">4</span>&gt;</span> <span class="token operator">&lt;</span>V1.<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>    <span class="token comment"># 注意顺序不要反</span><span class="token comment"># 将HEAD回到原先(最新)的位置</span>git-bisect reset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当遇到分支时，比如有4个分支，则定位每个分支中的<strong>最新节点</strong>，分别测试：</p><ul><li>若都存在该问题，则说明与这些分支无关，回到<strong>主分支</strong>中；</li><li>若<strong>1</strong>个分支存在，则追溯该分支；若<strong>2</strong>个分支存在，则追溯他俩上次分叉的位置；</li></ul><p><img src="/pics/git/git-bisect.png" alt="git-bisect"></p><h3 id="tig"><a href="#tig" class="headerlink" title="tig"></a>tig</h3><hr><p>tig作为git的可视化工具，对于开发人员来说是非常有用的工具。这里着重介绍一下tig相关的命令和快捷键：</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tig              <span class="token comment"># 查看当前项目的改动历史</span>tig <span class="token builtin class-name">.</span>            <span class="token comment"># 查看当前目录的改动历史</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意：只有当前目录为git仓库，tig才会有效。</p><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>进入到tig后，我们可以通过下面的快捷键来进行操作：</p><table><thead><tr><th align="left">键</th><th align="left">等价于</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">l</td><td align="left">git log</td><td align="left">详细的改动历史</td></tr><tr><td align="left">r</td><td align="left">git branch</td><td align="left">所有的分支</td></tr><tr><td align="left">s</td><td align="left">git status</td><td align="left">当前暂存和临时的修改</td></tr><tr><td align="left">c</td><td align="left">git stash pop</td><td align="left">查看临时保存的内容</td></tr><tr><td align="left">t</td><td align="left">tree</td><td align="left">以树形结构查看仓库，&lt;Enter&gt;进入 &lt;,&gt;退出</td></tr><tr><td align="left">/</td><td align="left">git branch</td><td align="left">当前提交中搜索关键词</td></tr><tr><td align="left">g</td><td align="left">grep</td><td align="left">所有提交中搜索关键词</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="uncategorized/hello-world/"/>
      <url>uncategorized/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>不安分的指针</title>
      <link href="language/pointer/"/>
      <url>language/pointer/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="基本篇"><a href="#基本篇" class="headerlink" title="基本篇"></a>基本篇</h2><hr><h3 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h3><hr><p>当提到指针，学过编程的我们第一反应：就是它让我从C入门到放弃…..说句实话，笔者在接触Linux之前，对它的态度亦是敬而远之，诸如”Segmentation fault”，”memory leak”这些令人抓狂的log是一切痛苦的根源，一个问题就能让初学C的我尝试解决大半天。但了解嵌入式相关的底层架构之后，笔者还是不由感叹，指针对于C来说，对于内存的访问确实高效！</p><p>在Google的搜索列表中，关于”C”, “指针”的结果总是与原理相关，偶然发现一个有趣的问题：指针为什么是C语言的精髓？</p><p>笔者借鉴以前在知乎上看到的一句话，非常值得思考：<strong>指针不是什么精髓，它只是一扇门，推开它后，就是一个世界</strong>。</p><h4 id="指针的概念"><a href="#指针的概念" class="headerlink" title="指针的概念"></a>指针的概念</h4><blockquote><p>指针是C/C++中用来<strong>指向</strong>内存地址的<strong>类型</strong>。</p></blockquote><p>注意：这句话的两个关键词：指向、类型。</p><h5 id="Q1-为什么不说指针就是内存地址，而要多一个指向？"><a href="#Q1-为什么不说指针就是内存地址，而要多一个指向？" class="headerlink" title="Q1: 为什么不说指针就是内存地址，而要多一个指向？"></a>Q1: 为什么不说指针就是内存地址，而要多一个<code>指向</code>？</h5><p>笔者认为“指针就是内存地址”的观点并不严谨，不然为何不称之为地址？<br>这里，<code>指向</code>表明它是一个<strong>过程</strong>，包含两个动作：</p><ol><li><p>根据地址索引找到内存块中的栈/堆区；</p></li><li><p>访问该栈/堆区，进行数据的读/写；</p></li></ol><h5 id="Q2-它属于基本数据类型吗？"><a href="#Q2-它属于基本数据类型吗？" class="headerlink" title="Q2: 它属于基本数据类型吗？"></a>Q2: 它属于基本数据类型吗？</h5><p>指针不属于基本数据类型，C11将它专门划分为：**<font color="#A013EC">指针类型</font>**。</p><h4 id="指针的定义"><a href="#指针的定义" class="headerlink" title="指针的定义"></a>指针的定义</h4><ul><li><p>指针<code>*p</code>：表示内存地址中的的数据；</p></li><li><p>指针变量<code>p</code>：表示内存地址；</p></li></ul><p>我们可以从下图形象地理解指针：</p><p><img src="/pics/ptr-figure.png" alt="poniter"></p><p>图中紫色地址保存的是指针p，红色地址保存的是变量var。而指针p本身的值就是var的地址，故表示：指针p指向变量var。</p><p>指针的赋值方式有两种操作(本质相同)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> a<span class="token punctuation">;</span>   <span class="token comment">// `指针p`指向`变量a` (实质指向地址)</span><span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>   <span class="token comment">// 把`变量a`的地址给`指针变量p`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意：这里<code>int</code>是指针的<strong>基类型</strong>。</p><h5 id="Q3：基类型是干什么的？"><a href="#Q3：基类型是干什么的？" class="headerlink" title="Q3：基类型是干什么的？"></a>Q3：基类型是干什么的？</h5><p>基类型包含基本数据类型、结构体等，它的作用是声明该指针在读写数据时的地址区域。我们知道，程序通过指针的地址从内存中读取数据，但是读多少呢？这就需要对指针指定一个基类型，用来告诉程序”<strong>读取多少数据</strong>“。下面举例指针在字符串中的应用，这里我把基类型称之为<strong>步长</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Jenny is walking her dog."</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"s: %s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// %s从字符串的起始地址开始读，直到遇到'\0'</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// *p从内存中获取字符，%c直接读*p</span>p<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token comment">// p每次走的步长即为基类型(char)的内存大小</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的例子，相信读者对基类型能有基本的理解。</p><p>阐明了指针如何读/写其他数据的方式，那指针本身又是如何存储的呢？</p><h5 id="Q4：指针本身分配内存吗？大小是多少？"><a href="#Q4：指针本身分配内存吗？大小是多少？" class="headerlink" title="Q4：指针本身分配内存吗？大小是多少？"></a>Q4：指针本身分配内存吗？大小是多少？</h5><p>值得一提的是，指针本身的数据类型为<span style="background-color:#00FA9A">unsigned int</span>，通过格式化中的转义字符可以验证。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> str<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 十进制—&gt; 1651581740</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 16进制—&gt; 0x7ffd6271232c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>指针在程序段中表示内存地址，无论我们定义的基类型是char还是struct，指针本身所占的内存空间(具体大小参考下表)都是不变的，但这<font color="#F1096F">不代表</font>它是基本数据类型。</p><p>指针所占内存空间取决于<strong>CPU的寻址位数</strong>。</p><table><thead><tr><th align="left">CPU寻址位数</th><th align="left">指针占内存空间</th></tr></thead><tbody><tr><td align="left">16</td><td align="left">2 bytes</td></tr><tr><td align="left">32</td><td align="left">4 bytes</td></tr><tr><td align="left">64</td><td align="left">8 bytes</td></tr></tbody></table><h3 id="为什么需要指针？"><a href="#为什么需要指针？" class="headerlink" title="为什么需要指针？"></a>为什么需要指针？</h3><hr><p>学习了指针的基本概念，或许有朋友会疑惑：指针并不友好，我们为什么需要它呢？你看Python、Java这些高级语言都没有指针，对于内存管理机制不是也很好吗？</p><h4 id="对比高级语言"><a href="#对比高级语言" class="headerlink" title="对比高级语言"></a>对比高级语言</h4><p>其实Java、Python(包括C++)中也有类似指针一样访问内存的机制——<strong>引用</strong>。有引用就一定有对象，对象可以是任何实体类型(类、数组、函数等)，其本质上也是指向内存地址，但请注意：引用只是一个傀儡，它不能被改变，只能被调用。具体可以从指针与引用的区别中体会：</p><ul><li>引用必须有初始化，<strong>不分配内存空间</strong>，指针未必有初始化，但分配内存空间；</li><li>引用的对象不能为空，指针可以为空；</li><li>引用的对象不能改变，指针初始化后还能改变；</li><li>“sizeof(引用)”=对象的大小，”sizeof(指针)”=指针本身大小；</li><li><strong>引用保证了程序的类型(内存)安全</strong>；</li></ul><p>这里额外提一下最后一点：引用在初始化时多了类型检查以保证内存安全，因此引用对象在调用时很少会出现”内存泄漏”等错误。</p><p>上面这些都是引用和指针的基本区别，其实第一点”不分配内存空间”就能推理出下面3点。从这些区别可以直观地感受到引用的局限性，相比之下，指针灵活很多，用户可以直接进行内存的管理分配，这就是为什么我们在嵌入式编程中(C)中需要指针。</p><h4 id="指针的作用"><a href="#指针的作用" class="headerlink" title="指针的作用"></a>指针的作用</h4><p>笔者认为指针是非常重要的，单凭一句话不足以说服大家。所以，我们来探讨一下指针的作用：</p><h5 id="1-高效地共享内存数据"><a href="#1-高效地共享内存数据" class="headerlink" title="1. 高效地共享内存数据"></a>1. 高效地共享内存数据</h5><p>在小规模的程序中，数据的共享可以通过赋值(复制)来实现。但是当代码量达到一定的规模时，这样的方式会占用大量的内存，比如我们传递结构体、链表、三维数组等。有了指针，我们可以直接把内存地址告诉程序段，实现数据的共享，既节省了内存的消耗，又提高了运行效率。</p><h5 id="2-动态地分配内存"><a href="#2-动态地分配内存" class="headerlink" title="2. 动态地分配内存"></a>2. 动态地分配内存</h5><p>普遍情况下，程序在声明变量时都是显式地分配内存(静态内存分配)。而当程序无法判断所声明对象需要多少内存时，就需要用到指针，实现在运行时分配内存(动态内存分配)。注意：</p><ul><li>静态内存分配：<strong>编译</strong>时分配，存放于**<font color="#A013EC">栈区</font>**。对象—&gt; 全局(静态)变量、局部静态变量；</li><li>动态内存分配：<strong>运行</strong>时分配，存放于**<font color="#A013EC">堆区</font>**。对象—&gt; 局部变量、动态内存分配(malloc)变量；</li></ul><h5 id="3-字符串处理"><a href="#3-字符串处理" class="headerlink" title="3. 字符串处理"></a>3. 字符串处理</h5><p>在Java中，几乎所有的字符串的处理都可调用其库中的工具类，而在C/C++中，常见的字符串处理函数常并不多，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 注意s为指针的话，此函数无效</span><span class="token function">strncpy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> src<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 字符串的赋值</span><span class="token function">strncmp</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 字符串的比较</span><span class="token function">snprintf</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> format <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 字符串的格式化赋值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当我们需要对字符串作其他处理，就必须用到指针。通过指针访问内存区，我们可以直接在每个步长中处理单个<strong>字符</strong>(char)，也可以进行遍历。例如，我们常用的<strong>链表结构</strong>，也是依赖于指针的帮助，无非是处理的步长从单个字符到单个链(结构体)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">p<span class="token operator">++</span><span class="token punctuation">;</span>                      <span class="token comment">// 字符串中的遍历方式</span>LNode_x <span class="token operator">=</span> LNode_x<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>  <span class="token comment">// 单链表中的遍历方式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="4-函数返回多个值"><a href="#4-函数返回多个值" class="headerlink" title="4. 函数返回多个值"></a>4. 函数返回多个值</h5><p>C语言规定：一个函数只能有一个返回值，我们只能通过return返回一个变量。<br>但是我们可以通过指针+<strong>结构体</strong>返回多个变量：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Person</span><span class="token punctuation">{</span><span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token keyword">int</span> gender<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">*</span>Prs<span class="token punctuation">;</span>Prs <span class="token operator">*</span><span class="token function">create_Per</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Prs <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>p<span class="token operator">-&gt;</span>name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token comment">// 赋值</span><span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实这里的多个变量，也可以理解为一个变量，只是我们定义了一个<strong>对象</strong>把多个变量封装起来。</p><blockquote><p>在基本篇中，我们着重讲述了指针的几个基本问题：what, how, why。而作为C语言的开发人员，仅仅知晓这些肯定是完全不够的，更多的细节问题还需要读者们在平时写代码中自行总结和发现。记住：<strong>编程的学习一定是在发现问题中得到成长</strong>。</p></blockquote><hr><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><hr><p>在接下来的进阶篇中，笔者将根据过往的经验总结一些指针在实际应用中的问题。</p><h3 id="指针的操作"><a href="#指针的操作" class="headerlink" title="指针的操作"></a>指针的操作</h3><hr><p>关于指针的操作，除了最基本的赋值与调用，在实际情况中还有许多相关的操作。例如，在函数传参中的调用、指针与指针变量的自增运算等。在阅读之前，笔者再次强调，指针是内存的访问，我们脑中必须要有<strong>内存单元</strong>的概念。</p><h4 id="函数传参中的指针引用"><a href="#函数传参中的指针引用" class="headerlink" title="函数传参中的指针引用"></a>函数传参中的指针引用</h4><p>首先，我们要清楚C语言关于的函数参数的一些概念：</p><ul><li><strong>形参</strong>(形式参数)：函数定义中，它所声明的参数变量(没有实际数据)；</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">TakeParm</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>source<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">char</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>实参</strong>(实际参数)：函数被调用时，它在当前程序段中调用的其他实体变量；</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">TakeParm</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> chr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当函数被调用时，程序会给形参<strong>分配</strong>相应类型大小的内存，实参的值传递给形参。注意传参是<strong>赋值</strong>、<strong>单向</strong>的，因此形参的值不会影响实参的值。但请特别注意：<span style="background-color:#F9FC17">当函数调用结束时，会立即释放<strong>形参</strong>的所分配的内存单元。</span></p><p>C语言的函数传参有两种方式：<strong>值传递</strong>、<strong>地址传递</strong>。</p><p>C++的函数传参有3种方式：值传递、地址传递、<strong>引用传递</strong>。</p><h5 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h5><p>该传参方式是把变量、常量、数组作为函数参数，本质上是把实参的值复制到形参的存储单元。这意味着形参和实参在不同内存单元中存储相同的值，故称之为”值传递”。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span>a <span class="token operator">=</span> b<span class="token punctuation">;</span>b <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d b=%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// a=4 b=9</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token function">Sub</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"m=%d n=%d\n"</span><span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// a=9 b=4</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子中，我们验证了值传递的本质：值的复制。不过，我们也发现了形参在函数中能够改变值，但在函数调用完后，两个值又“恢复原样”了。前面说过，由于传参的单向性，形参是不会影响到实参的值，因此m, n两个值压根就没有变动。那么如何让形参在函数调用时影响到实参？</p><h5 id="地址传递"><a href="#地址传递" class="headerlink" title="地址传递"></a>地址传递</h5><p>顾名思义，地址传递的意思是把地址作为传参，这就需要用到<strong>指针</strong>。严格来说，地址传递的对象是<strong>数组</strong>/指针，参数是<strong>数组的首地址</strong>/指针的值。因此，实参到形参传递的是地址，他们访问的便是相同的内存空间。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span><span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span><span class="token operator">*</span>b <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d b=%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// a=4 b=9</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token function">Sub</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"m=%d n=%d\n"</span><span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// a=4 b=9</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与值传递对比，实参和形参都有不同。实参中，<code>&amp;</code>代表<strong>取地址符</strong>，即把<code>m</code>和<code>n</code>的地址作为参数传给形参，注意：形参本身获取的是地址，等同于：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">a <span class="token operator">=</span> <span class="token operator">&amp;</span>m<span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token operator">&amp;</span>n<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样，指针变量a, b是m, n的地址，则对指针<code>*a</code>, <code>*b</code>的操作也就是对<code>m</code>, <code>n</code>变量的操作。所以，在函数调用结束后，实参得到了改变。</p><h5 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h5><p>再次强调，<span style="background-color:#F9FC17">C语言没有引用类型。</span>关于引用，我们在<strong>对比高级语言</strong>中介绍了它的特点(不多赘述)，它的取地址符<code>&amp;</code>。引用传递的本质其实也是通过指针来实现的，以指针的方式实现值传递。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>  <span class="token comment">// 形参的格式与值传递不同</span><span class="token punctuation">{</span><span class="token keyword">int</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span>a <span class="token operator">=</span> b<span class="token punctuation">;</span>b <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d b=%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// a=4 b=9</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token function">Sub</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"m=%d n=%d\n"</span><span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// a=9 b=4</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子，如果使用<code>gcc</code>编译一定会报错，而使用<code>g++</code>会执行通过。</p><p>了解原理之后，我们做一个总结：</p><ul><li>如果形参和实参都是基本数据类型，就是值传递；</li><li>如果实参是形参的指针，就是地址传递；</li><li>如果形参为引用类型<code>&amp;x</code>，就是引用类型；</li></ul><h4 id="p-or-p"><a href="#p-or-p" class="headerlink" title="*(p++) or (*p++) ?"></a>*(p++) or (*p++) ?</h4><p>关于指针的操作，前面提到过还有自增/减的操作。在基本变量中，<code>a++</code>等于<code>a=a+1</code>，那么，在指针里，<code>*p++</code>等于<code>*p=*p+1</code>吗？</p><p>正常情况下，<span style="background-color:#F9FC17">++优先级高于*</span>。</p><p>指针自增操作：</p><table><thead><tr><th align="left">表达式</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">*p++  /  *(p++)</td><td align="left">++在后，故先取值*p，再把指针变量p++(地址增加)</td></tr><tr><td align="left">(*p)++</td><td align="left">*p为整体，故先取值*p，再使*p的值++</td></tr><tr><td align="left">*++p  /  *(++p)</td><td align="left">++在前，故先把指针变量p++，再取值*p</td></tr><tr><td align="left">++*p</td><td align="left">*p为整体，故先使*p的值++，再取*p的值</td></tr></tbody></table><p>注意：第一行中的<code>*p++</code>，<code>*</code>与<code>p</code>是分离的。</p><p>可能有朋友看到这么绕的表达式，觉得脑子都要搞糊涂了….其实我们通过理解，根本不需要去记这些表达式的含义：</p><ul><li>当指针被括号括起来时，我们认为<code>(*p)</code>就是一个变量，把它当做<code>a++</code>处理就完事了；</li><li>当指针没有被括起来(<code>*</code>与<code>p</code>分离)时，我们认为<code>p++</code>就是地址的自增操作，然后再通过<code>*</code>取值；</li></ul><p>带着这样的思路，我们再回过头看这张表，是不是瞬间觉得简单易懂？</p><h3 id="指针的状态"><a href="#指针的状态" class="headerlink" title="指针的状态"></a>指针的状态</h3><hr><p>有朋友要问了，指针的状态不就是：NULL、存在地址和释放吗？这没啥好讨论的吧。如果是简单的使用，就记住这3个状态是没问题的，但既然是讲指针，笔者还是希望把深层的原理阐明清楚。</p><h4 id="NULL和空指针"><a href="#NULL和空指针" class="headerlink" title="NULL和空指针"></a>NULL和空指针</h4><h5 id="Q5：你能区分NULL指针、空指针、零指针吗？"><a href="#Q5：你能区分NULL指针、空指针、零指针吗？" class="headerlink" title="Q5：你能区分NULL指针、空指针、零指针吗？"></a>Q5：你能区分NULL指针、空指针、零指针吗？</h5><p>先把一些相关的概念问题罗列一下：</p><ul><li><strong>void*类型指针</strong>：通用变体型指针，可以不加转换直接赋值给其他指针；</li><li><strong>空指针常量</strong>：C标准中，值为0的整型常量/强制转为<code>void</code>类型的表达式；</li><li><strong>空指针</strong>：<code>p=0</code>，不指向任何实际对象/函数的指针；</li><li><strong>NULL指针</strong>：标准的宏定义，用来表示空指针常量；</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define NULL ((void*) 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>零指针</strong>：<code>*p=0</code>，值为0的指针，没有存储任何地址的指针，类型可以是<code>*void</code>, <code>*int</code>, <code>*char</code>等；</li></ul><p>综上，我们总结了一些平时几乎没有见到的各种指针状态，从应用角度来说，这些思维的区别几乎可以省略，因为它们都有一个特征：都可以转化为<code>*void</code>类型，说明了它们本身的存在是不依赖于实际对象。强调一下，<span style="background-color:#F9FC17">空指针包括NULL指针和零指针</span>。</p><h4 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h4><ul><li>野指针：未初始化的指针；</li><li>悬垂指针：从栈释放/删除一个对象后，指针仍然会指向该地址；</li></ul><p>在C语言中，指针是允许不被初始化，但是往往这样开放的规则会带来极大的危害。所有未初始化的指针都可以被称为野指针，直到该指针被赋予一个实际对象的内存地址。而在指针的释放机制中，<code>free(p)</code>释放的是指针指向的那一段内存空间，并非指针本身，如果悬垂指针在后续继续被调用，那它就是一个<strong>指向垃圾内存的指针</strong>，这样的指针是很容易使程序运行致崩溃。</p><p>对于上述这些情况，我们能够最恰当的解决方式是全部赋予空指针常量：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char *p = NULL;...free(p);p = NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法介绍</title>
      <link href="grammar/Markdown/"/>
      <url>grammar/Markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><h4 id="1-粗体-斜体"><a href="#1-粗体-斜体" class="headerlink" title="1.粗体/斜体"></a>1.粗体/斜体<br></h4><p>使用语法：</p><blockquote><p>**粗体**   *斜体*   ***粗体+斜体***</p></blockquote><p> <strong>粗体</strong>   <em>斜体</em>   <em><strong>粗体+斜体</strong></em></p><h4 id="2-删除线"><a href="#2-删除线" class="headerlink" title="2.删除线"></a>2.删除线<br></h4><p>使用语法：</p><blockquote><p>~~这句话不要了~~</p></blockquote><p><del>这句话不要了</del></p><h4 id="3-高亮"><a href="#3-高亮" class="headerlink" title="3.高亮"></a>3.高亮</h4><p>当我们需要在一段话中高亮某些关键词，可以用&lt;html&gt;中的&lt;span&gt;标签来强调。</p><blockquote><p>VPN对数据包的处理是 &lt;span style=”background-color:#ffd351”&gt;通过封装包头(header)&lt;/span&gt;，继而在GFW外的主机上进行剥离，反之亦然。 </p></blockquote><p>VPN对数据包的处理是 <span style="background-color:#ffd351">通过封装包头(header)</span> ，继而在GFW外的主机上进行剥离，反之亦然。</p><hr><h3 id="引用内容"><a href="#引用内容" class="headerlink" title="引用内容"></a>引用内容</h3><blockquote><p>当我们需要引用内容时，可以再前面加 ‘&gt;’<br><br>如果需要换行，可以在末尾+两个空格/‘&lt;br&gt;‘</p><blockquote><p>这是嵌套引用<br></p><blockquote><p>如果吃饱了没事干，可以一直套娃<br></p></blockquote></blockquote></blockquote><p>尽量不要嵌套引用，不美观。</p><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>可以用 ‘*’ ‘+’ ‘-‘ 作为标记</li></ul><ul><li>我还是习惯用’-‘吧，’*‘ 容易与<strong>粗体</strong>搞混</li></ul><h4 id="1-有序列表"><a href="#1-有序列表" class="headerlink" title="1.有序列表"></a>1.有序列表</h4><ol><li>开头必须是数字，后面必须跟’.’</li><li>注意：’.’后面一定要有<strong>空格</strong></li><li>如果下面也有序号列表，当中要空一行，否则序号承接</li></ol><h4 id="2-嵌套列表"><a href="#2-嵌套列表" class="headerlink" title="2.嵌套列表"></a>2.嵌套列表</h4><ol><li><p>first floor</p></li><li><p>second floor</p><ol><li>2-1</li><li>2-2</li></ol></li><li><p>third floor</p><ul><li>有序无序可随意嵌套；</li><li>标记后面一定要有空格；</li><li>当然，利用转义字符’.‘，它就不再是个列表了；</li></ul></li><li><p>fourth floor<br>…..</p></li></ol><hr><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线必须是3个以上的字符 *, -, _表示, 字符间可以有空格，但不能有其他字符</p><blockquote><p>***   - - -   _ __</p></blockquote><p>显示：(分割线)</p><hr><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>使用语法：<br>“|” 分隔单元格，”-“ 分隔表头和行</p><blockquote><p>| name | age |<br>| :—-:    | :— |<br>| Twyz  | 24 |<br>| Jenny | 25 |</p></blockquote><table><thead><tr><th align="center">name</th><th align="left">age</th></tr></thead><tbody><tr><td align="center">Twyz</td><td align="left">24</td></tr><tr><td align="center">Jenny</td><td align="left">25</td></tr></tbody></table><p>表头下方的分割线标记，代表了对齐方式：</p><ul><li><strong>:—</strong> 左对齐</li><li><strong>:—:</strong> 居中对齐</li><li><strong>—:</strong> 右对齐</li></ul><blockquote><p>| left | center | right |<br>|:—- | :—-: | —-: |<br>| aaaa | bbbbbb | ccccc |<br>| a  |  b  |  c  |</p></blockquote><table><thead><tr><th align="left">left</th><th align="center">center</th><th align="right">right</th></tr></thead><tbody><tr><td align="left">aaaa</td><td align="center">bbbbbb</td><td align="right">ccccc</td></tr><tr><td align="left">a</td><td align="center">b</td><td align="right">c</td></tr></tbody></table><hr><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>使用语法：</p><blockquote><p>[markdown基本语法](<a href="https://xianbai.me/learn-md/index.html)/">https://xianbai.me/learn-md/index.html)\</a><br></p></blockquote><p><a href="https://xianbai.me/learn-md/index.html">markdown基本语法</a><br><br>或者直接用原地址：<a href="http://www.baidu.com/">http://www.baidu.com/</a><br><br>这适合较短的网址</p><hr><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>使用语法：</p><blockquote><p>![panda](<a href="https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100">https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100</a> “GitHub,Social Coding”)</p></blockquote><p><img src="https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100" alt="GitHub" title="GitHub,Social Coding"></p><p>也可设置图片大小</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>GitHub,Social Coding<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100" alt="GitHub" title="GitHub,Social Coding" width="70" height="70"><hr><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>使用语法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h3><p>使用语法：</p><blockquote><p>:&lt;表情代码&gt;:</p></blockquote><p>举例：</p><blockquote><p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>      smile<br><span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>      laughing<br>:+1:      +1<br><span class="github-emoji"><span>👏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>      clap</p></blockquote><p>更多的表情，请参考：<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">webpage-tool</a><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> grammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
